<!DOCTYPE html>
<!--
  ZeroPrompt Warp Background V2 - Standalone Demo
  
  CSP-Compliant Version:
  - Uses cdnjs.cloudflare.com (whitelisted CDN)
  - Pure JavaScript (no Babel/JSX compilation)
  - No external dependencies beyond React/Three.js
  
  Embedded Profiles:
  - Default: General AI prompt vocabulary (188+ trillion combinations)
  - Volkyri: Sci-fi warrior aesthetic from Hel Vortex system
  - Switch profiles with 'P' key
  
  Subfolder Support:
  - Works in any path including /prompt-warp-2/
  - All resources use absolute CDN URLs
  
  Usage:
  - Simply open this file in a web browser
  - No build process required
  - No local server needed
  - Press 'I' for controls and info
-->
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ZeroPrompt Warp Background V2 - Demo (CSP-Compliant)</title></title>
  <style>
    :root {
      --theme-color: #00CED1;
      --theme-color-light: rgba(0, 206, 209, 0.2);
      --theme-color-border: rgba(0, 206, 209, 0.27);
    }
    
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Courier New', monospace;
      background: #000;
      color: var(--theme-color);
      overflow: hidden;
    }
    
    #info-overlay {
      position: fixed;
      top: 20px;
      left: 20px;
      background: rgba(0, 0, 0, 0.85);
      border: 2px solid var(--theme-color);
      border-radius: 8px;
      padding: 20px;
      max-width: 400px;
      backdrop-filter: blur(10px);
      z-index: 10000;
    }
    
    #info-overlay h1 {
      font-size: 20px;
      margin-bottom: 10px;
      color: var(--theme-color);
    }
    
    #info-overlay p {
      font-size: 12px;
      line-height: 1.6;
      margin-bottom: 15px;
      opacity: 0.9;
    }
    
    #info-overlay .feature-list {
      font-size: 11px;
      margin-bottom: 15px;
    }
    
    #info-overlay .feature-list div {
      margin-bottom: 8px;
      padding-left: 15px;
      position: relative;
    }
    
    #info-overlay .feature-list div::before {
      content: "â–¸";
      position: absolute;
      left: 0;
    }
    
    #hide-info {
      width: 100%;
      padding: 8px;
      background: #00CED1;
      color: #000;
      border: none;
      border-radius: 4px;
      font-family: 'Courier New', monospace;
      font-weight: bold;
      cursor: pointer;
      font-size: 12px;
    }
    
    #hide-info:hover {
      background: #00FFF5;
    }
    
    #show-info {
      position: fixed;
      top: 20px;
      left: 20px;
      padding: 12px 16px;
      background: var(--theme-color-light);
      border: 2px solid var(--theme-color);
      border-radius: 8px;
      color: var(--theme-color);
      font-family: 'Courier New', monospace;
      font-weight: bold;
      cursor: pointer;
      backdrop-filter: blur(10px);
      z-index: 10000;
      display: none;
    }
    
    #show-info:hover {
      background: rgba(0, 206, 209, 0.4);
    }
    
    .link {
      color: var(--theme-color);
      text-decoration: none;
      font-weight: bold;
    }
    
    .link:hover {
      text-decoration: underline;
    }
    
    #profile-notification {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: var(--theme-color);
      color: #000;
      padding: 20px 40px;
      border-radius: 8px;
      font-family: 'Courier New', monospace;
      font-weight: bold;
      font-size: 18px;
      z-index: 20000;
      display: none;
      animation: fadeInOut 2s ease-in-out;
    }
    
    @keyframes fadeInOut {
      0% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
      20% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
      80% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
      100% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
    }
  </style>
</head>
<body>
  <div id="root"></div>
  
  <div id="info-overlay">
    <h1>ðŸš€ ZeroPrompt Warp BG V2</h1>
    <p>
      Interactive 3D visualization of procedural prompt generation using position-is-seed methodology.
    </p>
    
    <div class="feature-list">
      <div><strong>Current Profile:</strong> <span id="profile-name">Default</span></div>
      <div><strong>Elastic Billboards:</strong> Multi-line text scaling</div>
      <div><strong>Speed Scaling:</strong> Slower = larger text</div>
      <div><strong>Infinite Prompts:</strong> Deterministic generation</div>
    </div>
    
    <div style="margin: 15px 0; padding: 10px; background: rgba(0, 206, 209, 0.1); border: 1px solid var(--theme-color-border); border-radius: 4px;">
      <div style="font-weight: bold; margin-bottom: 8px; font-size: 11px;">Keyboard Controls:</div>
      <div style="font-size: 10px; line-height: 1.5;">
        <strong>1/2/3:</strong> Speed (-10% / Reset / +10%)<br>
        <strong>5:</strong> Reverse Direction<br>
        <strong>C:</strong> Cycle Color Theme<br>
        <strong>P:</strong> Switch Profile (Default â†” Volkyri)<br>
        <strong>S:</strong> New Random Seed<br>
        <strong>H:</strong> Toggle UI<br>
        <strong>I:</strong> Toggle This Info
      </div>
    </div>
    
    <p style="font-size: 11px; margin-top: 15px; padding-top: 15px; border-top: 1px solid var(--theme-color-border);">
      <strong>Repository:</strong><br>
      <a href="https://github.com/MushroomFleet/zeroprompt-warpBG-JSX" class="link" target="_blank">
        github.com/MushroomFleet/zeroprompt-warpBG-JSX
      </a>
    </p>
    
    <button id="hide-info">Hide Info (I)</button>
  </div>
  
  <button id="show-info">Show Info (I)</button>
  
  <div id="profile-notification"></div>

  <!-- React, ReactDOM, and Three.js from allowed CDN -->
  <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
  <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

  <!-- Pure JavaScript Component (No JSX) -->
  <script>
    const { useState, useEffect, useRef } = React;

    // =============================================================================
    // DEFAULT PROFILE - Embedded fallback
    // =============================================================================

    const DEFAULT_PROFILE = {
      "name": "Default",
      "description": "Full vocabulary profile with all categories - 188+ trillion combinations",
      "version": "1.0.0",
      
      "templates": [
        "{subject} {action} {environment}, {style}, {lighting}, {camera}, {details}, {mood} atmosphere",
        "{camera} of {subject} {action} {environment}, {style}, {lighting}, {details}, {mood}",
        "{style} {subject}, {environment}, {lighting}, {mood} mood, {details}",
        "{subject} in {environment}, {mood} {style}, {lighting}, {camera}, {details}",
        "{mood} scene of {subject} {action} {environment}, {style}, {lighting}, {details}",
        "{style} depicting {subject}, {environment} setting, {lighting}, {camera}",
        "{camera}, {subject} {action} {environment}, {style}, {mood}, {details}",
        "{subject}, {environment}, {style}, {lighting}, {mood} atmosphere, {details}"
      ],
      
      "pools": {
        "subject": [
          "a woman", "a man", "a young woman", "a young man", "an elderly woman",
          "an elderly man", "a child", "a teenager", "a couple", "a group of people",
          "a knight", "a wizard", "a witch", "a sorceress", "a necromancer",
          "a paladin", "a rogue", "an assassin", "a ranger", "a barbarian",
          "a cyborg", "an android", "a robot", "a mech pilot", "an astronaut",
          "a dragon", "a phoenix", "a griffin", "a unicorn", "a werewolf"
        ],
        
        "action": [
          "standing in", "sitting in", "kneeling in", "floating above", "hovering over",
          "walking through", "running through", "flying over", "swimming in", "climbing",
          "fighting in", "battling through", "defending", "attacking", "dueling in",
          "exploring", "discovering", "searching through", "investigating"
        ],
        
        "environment": [
          "a dark forest", "an enchanted forest", "a misty forest", "a bamboo forest",
          "a snowy mountain", "a volcanic mountain", "a floating mountain",
          "a medieval castle", "a ruined fortress", "a gothic cathedral",
          "a cyberpunk city", "a neon-lit alley", "a futuristic metropolis",
          "a space station", "an alien planet", "a crystal cave"
        ],
        
        "style": [
          "photorealistic", "hyperrealistic", "cinematic", "film still",
          "oil painting", "watercolor painting", "digital painting",
          "anime style", "manga style", "cyberpunk aesthetic"
        ],
        
        "lighting": [
          "golden hour lighting", "dramatic rim lighting", "neon lighting",
          "volumetric lighting", "moonlight", "firelight"
        ],
        
        "camera": [
          "close-up portrait", "wide shot", "low angle shot", "bird's eye view",
          "shallow depth of field", "bokeh background"
        ],
        
        "details": [
          "highly detailed", "intricate details", "sharp focus",
          "8k", "masterpiece", "trending on artstation"
        ],
        
        "mood": [
          "serene", "peaceful", "mysterious", "ominous", "epic",
          "dramatic", "ethereal", "nostalgic", "intense"
        ]
      }
    };

    // =============================================================================
    // VOLKYRI PROFILE - Embedded alternative
    // =============================================================================

    const VOLKYRI_PROFILE = {
      "name": "Volkyri Aesthetic Generator",
      "description": "Ancient starfaring warrior-attendants from the Hel Vortex system",
      "version": "2.0.0",
      
      "templates": [
        "Volkyri {role} in {primary_metal} metallic bodysuit with {accent_color} accent panels, single {horn_shape} half-horn growing from {horn_side}, bone fused with {horn_sheath} sheathing. {action}. Expression of {expression}. {environment}. {lighting}. {skin_tone} skin, {hair}. {camera}. {style_tag}.",
        "Volkyri {role} wearing form-fitting {primary_metal} chrome attire with {accent_color} trim, asymmetrical {horn_shape} horn emerging from {horn_side} skull. {action}. {expression} gaze. {environment}. {lighting} catches metallic sheen. {camera}, {composition}. {style_tag}, feminine martial elegance.",
        "{role} of the Volkyri in {primary_metal} bodysuit, {accent_color} accents across chest panel, single {horn_shape} horn fused to {horn_side} temple with {horn_sheath} plating. {action}. Expression of {expression}, {eye_detail}. {environment}. {lighting}. {camera} showing {pose_detail}. {style_tag}.",
        "Lone Volkyri {role} clad in {primary_metal} metallic armor-skin with {accent_color} highlights, {horn_shape} half-horn jutting from {horn_side} at aggressive angle. {action}. {expression} composure despite {situation}. {environment}. {lighting}. {hair} flowing opposite the horn. {camera}. {style_tag}, solitary presence."
      ],
      
      "pools": {
        "role": [
          "warrior-scholar", "beast-handler", "diplomat", "hunt-mistress", "sentinel",
          "acrobat-assassin", "executrix", "blade-dancer", "void-walker", "throne-guard"
        ],
        "horn_shape": ["swept-blade", "conical spire", "flame-swept", "geometric plated", "spiral-twist", "curved-talon"],
        "horn_side": ["left-temple", "right-temple"],
        "horn_sheath": ["polished chrome", "gunmetal", "golden metal", "bronze", "void-black metal", "silver"],
        "primary_metal": ["gold", "silver", "bronze", "gunmetal", "void chrome", "copper", "pale platinum"],
        "accent_color": ["absolute black", "deep purple", "crimson red", "pale gray", "dark teal", "midnight blue"],
        "expression": ["cold assessment", "subtle menace", "regal composure", "fierce focus", "glacial serenity"],
        "action": [
          "She holds an ancient data-tome with both hands, scanning illuminated text",
          "One gloved hand raised in command gesture, stance unwavering",
          "Standing at attention, blade held vertically before her face",
          "Drawing curved blade from spine-mounted sheath",
          "Examining artifact held at eye level"
        ],
        "environment": [
          "Within dimly lit archive chamber of ancient texts",
          "Rocky volcanic terrain with ash-filled sky and distant magma glow",
          "Industrial gothic fortress interior with deep pooling shadows",
          "Void space backdrop with distant nebula swirling",
          "Obsidian throne chamber beneath vaulted metallic ceiling"
        ],
        "lighting": [
          "Dramatic rim lighting from behind creates silhouette edge",
          "Single harsh key light with deep shadows",
          "Metallic surfaces catching bright specular highlights",
          "Purple accent lighting bathes scene in cold glow"
        ],
        "camera": ["Medium shot", "Full body shot", "Close-up portrait", "Profile view highlighting horn silhouette"],
        "composition": ["centered framing", "rule of thirds placement", "asymmetrical balance"],
        "skin_tone": ["Pale", "Porcelain", "Alabaster", "Ash-white"],
        "hair": [
          "dark hair slicked back from the asymmetrical horn",
          "silver-white hair cropped close to skull",
          "hair shaved on horn side, long on opposite"
        ],
        "eye_detail": ["amber eyes scanning surroundings", "ice-blue gaze cutting through shadow"],
        "pose_detail": ["martial readiness", "aristocratic bearing", "coiled tension"],
        "emphasis": ["the horn's asymmetrical silhouette", "metallic surface reflections"],
        "situation": ["surrounding chaos", "imminent combat", "isolation"],
        "style_tag": ["Volkyri aesthetic", "Hel Vortex origin", "Throne Eternal legacy"]
      }
    };

    // Profile registry
    const EMBEDDED_PROFILES = {
      'default': DEFAULT_PROFILE,
      'volkyri': VOLKYRI_PROFILE
    };

    // =============================================================================
    // COLOR PALETTE - Cycling theme colors
    // =============================================================================

    const COLOR_PALETTE = [
      { name: 'Teal', hex: '#00CED1', rgb: [0, 206, 209] },
      { name: 'Magenta', hex: '#FF1493', rgb: [255, 20, 147] },
      { name: 'Orange', hex: '#FF8C00', rgb: [255, 140, 0] },
      { name: 'Lime', hex: '#00FF7F', rgb: [0, 255, 127] },
      { name: 'Purple', hex: '#9370DB', rgb: [147, 112, 219] },
      { name: 'Gold', hex: '#FFD700', rgb: [255, 215, 0] },
      { name: 'Crimson', hex: '#DC143C', rgb: [220, 20, 60] },
      { name: 'Cyan', hex: '#00FFFF', rgb: [0, 255, 255] }
    ];

    // =============================================================================
    // HASH FUNCTIONS
    // =============================================================================

    function simpleHash(seed, ...coords) {
      let hash = seed & 0xFFFFFFFF;
      for (let coord of coords) {
        hash ^= coord;
        hash = Math.imul(hash, 0x01000193);
      }
      return Math.abs(hash);
    }

    function hashToIndex(hash, poolSize) {
      return hash % poolSize;
    }

    function generatePrompt(seed, promptIdx, profile) {
      const templates = profile.templates;
      const pools = profile.pools;
      
      const templateHash = simpleHash(seed, promptIdx, 0);
      const template = templates[hashToIndex(templateHash, templates.length)];
      
      const components = {};
      let i = 1;
      for (const [key, pool] of Object.entries(pools)) {
        const componentHash = simpleHash(seed, promptIdx, i);
        components[key] = pool[hashToIndex(componentHash, pool.length)];
        i++;
      }
      
      let result = template;
      for (const [key, value] of Object.entries(components)) {
        result = result.replace(new RegExp(`\\{${key}\\}`, 'g'), value);
      }
      
      return result;
    }

    // =============================================================================
    // REACT COMPONENT
    // =============================================================================

    const ZeroPromptWarpBGV2 = () => {
      const containerRef = useRef(null);
      const sceneRef = useRef(null);
      const rendererRef = useRef(null);
      const cameraRef = useRef(null);
      const billboardsRef = useRef([]);
      const particlesRef = useRef(null);
      
      const [webglError, setWebglError] = useState(null);
      const [showControls, setShowControls] = useState(true);
      
      // Profile selection
      const [selectedProfile, setSelectedProfile] = useState('default');
      const currentProfile = EMBEDDED_PROFILES[selectedProfile];
      
      // Color cycling
      const [colorIndex, setColorIndex] = useState(0);
      const currentColor = COLOR_PALETTE[colorIndex];
      
      const seedRef = useRef(42);
      const [seed, setSeed] = useState(42);
      const promptIndexRef = useRef(0);
      
      const DEFAULT_SPEED = 1.0;
      const speedRef = useRef(DEFAULT_SPEED);
      const targetSpeedRef = useRef(DEFAULT_SPEED);
      const [displaySpeed, setDisplaySpeed] = useState(DEFAULT_SPEED);
      const LERP_FACTOR = 0.05;
      
      const directionForwardRef = useRef(true);
      const [isForward, setIsForward] = useState(true);

      // Update CSS variables when color changes
      useEffect(() => {
        const root = document.documentElement;
        root.style.setProperty('--theme-color', currentColor.hex);
        root.style.setProperty('--color-index', colorIndex.toString());
        
        // Calculate lighter version for backgrounds (20% opacity)
        const rgb = currentColor.rgb;
        root.style.setProperty('--theme-color-light', `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.2)`);
        root.style.setProperty('--theme-color-border', `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0.27)`);
      }, [colorIndex, currentColor]);

      useEffect(() => {
        const checkWebGL = () => {
          try {
            const canvas = document.createElement('canvas');
            const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
            return !!gl;
          } catch (e) {
            return false;
          }
        };

        if (!checkWebGL()) {
          setWebglError('WebGL is not supported in your browser.');
          return;
        }

        try {
          const scene = new THREE.Scene();
          scene.background = new THREE.Color(0x000000);
          sceneRef.current = scene;

          const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
          camera.position.z = 0;
          cameraRef.current = camera;

          const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false, powerPreference: 'high-performance' });
          renderer.setSize(window.innerWidth, window.innerHeight);
          renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
          
          if (!containerRef.current) {
            setWebglError('Container not ready');
            return;
          }
          
          while (containerRef.current.firstChild) {
            containerRef.current.removeChild(containerRef.current.firstChild);
          }
          
          containerRef.current.appendChild(renderer.domElement);
          rendererRef.current = renderer;

          const handleKeyPress = (event) => {
            if (event.key === '1') {
              targetSpeedRef.current = Math.max(0.1, targetSpeedRef.current * 0.9);
              setDisplaySpeed(targetSpeedRef.current);
            } else if (event.key === '2') {
              targetSpeedRef.current = DEFAULT_SPEED;
              setDisplaySpeed(DEFAULT_SPEED);
            } else if (event.key === '3') {
              targetSpeedRef.current = Math.min(5.0, targetSpeedRef.current * 1.1);
              setDisplaySpeed(targetSpeedRef.current);
            } else if (event.key === '5') {
              directionForwardRef.current = !directionForwardRef.current;
              setIsForward(directionForwardRef.current);
            } else if (event.key === 'c' || event.key === 'C') {
              // Cycle through colors
              setColorIndex(prev => (prev + 1) % COLOR_PALETTE.length);
            } else if (event.key === 'p' || event.key === 'P') {
              // Toggle between profiles
              setSelectedProfile(prev => prev === 'default' ? 'volkyri' : 'default');
            } else if (event.key === 's' || event.key === 'S') {
              const newSeed = Math.floor(Math.random() * 0xFFFFFFFF);
              seedRef.current = newSeed;
              setSeed(newSeed);
            } else if (event.key === 'h' || event.key === 'H') {
              setShowControls(prev => !prev);
            } else if (event.key === 'i' || event.key === 'I') {
              const info = document.getElementById('info-overlay');
              const showBtn = document.getElementById('show-info');
              if (info.style.display === 'none') {
                info.style.display = 'block';
                showBtn.style.display = 'none';
              } else {
                info.style.display = 'none';
                showBtn.style.display = 'block';
              }
            }
          };
          
          window.addEventListener('keypress', handleKeyPress);

          const createBillboard = (index, currentSpeed, isForward) => {
            promptIndexRef.current += 1;
            const promptText = generatePrompt(seedRef.current, promptIndexRef.current, currentProfile);
            
            const speedScale = Math.max(0.6, Math.min(2.0, 1.0 / Math.sqrt(currentSpeed)));
            
            const wrapText = (text, maxCharsPerLine = 50) => {
              const words = text.split(' ');
              const lines = [];
              let currentLine = '';
              
              for (const word of words) {
                const testLine = currentLine ? `${currentLine} ${word}` : word;
                if (testLine.length <= maxCharsPerLine) {
                  currentLine = testLine;
                } else {
                  if (currentLine) lines.push(currentLine);
                  currentLine = word;
                }
              }
              if (currentLine) lines.push(currentLine);
              return lines;
            };
            
            const lines = wrapText(promptText, 50);
            const numLines = Math.max(1, lines.length);
            
            const charsPerLine = Math.max(...lines.map(l => l.length));
            const baseFontSize = 42;
            const fontSize = Math.floor(baseFontSize * speedScale);
            const lineHeight = Math.floor(60 * speedScale);
            const padding = Math.floor(40 * speedScale);
            
            const canvasWidth = Math.max(1024, Math.floor(charsPerLine * 20 * speedScale));
            const canvasHeight = (numLines * lineHeight) + (padding * 2);
            
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
            
            context.fillStyle = '#000000';
            context.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw multi-line text with current theme color
            context.fillStyle = currentColor.hex;
            context.font = `bold ${fontSize}px monospace`;
            context.textAlign = 'center';
            context.textBaseline = 'top';
            
            const startY = padding;
            lines.forEach((line, i) => {
              context.fillText(line, canvas.width / 2, startY + (i * lineHeight));
            });
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            
            const billboardWidth = 24 * speedScale;
            const billboardHeight = (canvasHeight / canvasWidth) * billboardWidth;
            
            const geometry = new THREE.PlaneGeometry(billboardWidth, billboardHeight);
            const material = new THREE.MeshBasicMaterial({ map: texture, transparent: true, opacity: 0.8, side: THREE.DoubleSide });
            
            const billboard = new THREE.Mesh(geometry, material);
            
            const angle = (index / 30) * Math.PI * 2;
            const radius = 15 + (index % 3) * 5;
            const distance = isForward ? -50 - (Math.random() * 100) : 10 + (Math.random() * 100);
            
            const opacity = 0.3 + Math.random() * 0.5;
            billboard.material.opacity = opacity;
            
            billboard.position.x = Math.cos(angle) * radius;
            billboard.position.y = Math.sin(angle) * radius - 5;
            billboard.position.z = distance;
            
            billboard.lookAt(camera.position);
            
            billboard.userData = {
              baseVelocity: 2 + Math.random() * 1,
              initialZ: distance,
              baseOpacity: opacity
            };
            
            scene.add(billboard);
            return billboard;
          };

          const numBillboards = 30;
          for (let i = 0; i < numBillboards; i++) {
            billboardsRef.current.push(createBillboard(i, DEFAULT_SPEED, true));
          }

          const particleCount = 1000;
          const particleGeometry = new THREE.BufferGeometry();
          const particlePositions = new Float32Array(particleCount * 3);
          const particleVelocities = new Float32Array(particleCount);
          const particleInitialZ = new Float32Array(particleCount);
          
          for (let i = 0; i < particleCount; i++) {
            const i3 = i * 3;
            const angle = Math.random() * Math.PI * 2;
            const radius = Math.random() * 30;
            
            particlePositions[i3] = Math.cos(angle) * radius;
            particlePositions[i3 + 1] = Math.sin(angle) * radius - 5;
            particlePositions[i3 + 2] = -Math.random() * 200;
            
            particleVelocities[i] = 2 + Math.random() * 1;
            particleInitialZ[i] = particlePositions[i3 + 2];
          }
          
          particleGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
          
          // Convert current color hex to THREE.Color
          const particleColor = new THREE.Color(currentColor.hex);
          
          const particleMaterial = new THREE.PointsMaterial({
            color: particleColor,
            size: 0.2,
            transparent: true,
            opacity: 0.6,
            blending: THREE.AdditiveBlending
          });
          
          const particles = new THREE.Points(particleGeometry, particleMaterial);
          particles.userData.velocities = particleVelocities;
          particles.userData.initialZ = particleInitialZ;
          particles.userData.activeCount = particleCount;
          scene.add(particles);
          particlesRef.current = particles;

          let animationId = null;
          let isAnimating = true;
          
          const animate = () => {
            if (!isAnimating) return;
            animationId = requestAnimationFrame(animate);
            
            speedRef.current += (targetSpeedRef.current - speedRef.current) * LERP_FACTOR;
            const isForward = directionForwardRef.current;
            
            billboardsRef.current.forEach((billboard, index) => {
              billboard.lookAt(camera.position);
              
              if (isForward) {
                billboard.position.z += billboard.userData.baseVelocity * speedRef.current;
              } else {
                billboard.position.z -= billboard.userData.baseVelocity * speedRef.current;
              }
              
              if (!isForward) {
                const fadeStartDistance = -50;
                const fadeEndDistance = -150;
                
                if (billboard.position.z < fadeStartDistance) {
                  const fadeProgress = Math.max(0, Math.min(1, 
                    (fadeStartDistance - billboard.position.z) / (fadeStartDistance - fadeEndDistance)
                  ));
                  billboard.material.opacity = billboard.userData.baseOpacity * (1 - fadeProgress);
                } else {
                  billboard.material.opacity = billboard.userData.baseOpacity;
                }
              } else {
                billboard.material.opacity = billboard.userData.baseOpacity;
              }
              
              const shouldRecycle = isForward ? (billboard.position.z > 10) : (billboard.position.z < -150);
              
              if (shouldRecycle) {
                scene.remove(billboard);
                billboard.geometry.dispose();
                billboard.material.map.dispose();
                billboard.material.dispose();
                
                billboardsRef.current[index] = createBillboard(index, speedRef.current, isForward);
              }
            });
            
            const targetParticleCount = Math.floor(Math.min(1000, 100 + (speedRef.current * 900)));
            particles.userData.activeCount = targetParticleCount;
            
            const positions = particles.geometry.attributes.position.array;
            const velocities = particles.userData.velocities;
            const initialZ = particles.userData.initialZ;
            
            for (let i = 0; i < particleCount; i++) {
              const i3 = i * 3;
              
              if (i < particles.userData.activeCount) {
                if (isForward) {
                  positions[i3 + 2] += velocities[i] * speedRef.current;
                  if (positions[i3 + 2] > 10) {
                    positions[i3 + 2] = -200;
                    initialZ[i] = -200;
                  }
                } else {
                  positions[i3 + 2] -= velocities[i] * speedRef.current;
                  if (positions[i3 + 2] < -200) {
                    positions[i3 + 2] = 10;
                    initialZ[i] = 10;
                  }
                }
              } else {
                positions[i3 + 2] = -10000;
              }
            }
            
            particles.geometry.attributes.position.needsUpdate = true;
            renderer.render(scene, camera);
          };
          
          animate();

          const handleResize = () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
          };
          
          window.addEventListener('resize', handleResize);

          return () => {
            isAnimating = false;
            if (animationId) cancelAnimationFrame(animationId);
            
            window.removeEventListener('resize', handleResize);
            window.removeEventListener('keypress', handleKeyPress);
            
            if (billboardsRef.current && scene) {
              billboardsRef.current.forEach(billboard => {
                if (billboard && scene) {
                  scene.remove(billboard);
                  if (billboard.geometry) billboard.geometry.dispose();
                  if (billboard.material) {
                    if (billboard.material.map) billboard.material.map.dispose();
                    billboard.material.dispose();
                  }
                }
              });
            }
            
            if (particles && scene) {
              scene.remove(particles);
              if (particles.geometry) particles.geometry.dispose();
              if (particles.material) particles.material.dispose();
            }
            
            if (renderer) {
              renderer.dispose();
              if (containerRef.current && renderer.domElement && containerRef.current.contains(renderer.domElement)) {
                containerRef.current.removeChild(renderer.domElement);
              }
            }
          };
        } catch (error) {
          console.error('WebGL initialization error:', error);
          setWebglError(`Failed to initialize 3D graphics: ${error.message}`);
        }
      }, [seed, selectedProfile, colorIndex]);

      if (webglError) {
        return React.createElement('div', {
          style: {
            position: 'fixed',
            top: '50%',
            left: '50%',
            transform: 'translate(-50%, -50%)',
            background: 'rgba(0, 0, 0, 0.95)',
            border: '2px solid #ff0000',
            borderRadius: '12px',
            padding: '40px',
            color: '#ff6666',
            fontFamily: 'monospace',
            textAlign: 'center',
            maxWidth: '600px'
          }
        }, [
          React.createElement('div', { 
            key: 'error-title',
            style: { fontSize: '24px', fontWeight: 'bold', marginBottom: '20px', color: '#ff0000' }
          }, 'âš  WebGL Error'),
          React.createElement('div', { key: 'error-msg' }, webglError)
        ]);
      }

      return React.createElement('div', {
        ref: containerRef,
        style: { width: '100vw', height: '100vh' }
      });
    };

    // Render
    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(React.createElement(ZeroPromptWarpBGV2));
  </script>

  <script>
    // Info overlay toggle
    document.getElementById('hide-info').addEventListener('click', () => {
      document.getElementById('info-overlay').style.display = 'none';
      document.getElementById('show-info').style.display = 'block';
    });

    document.getElementById('show-info').addEventListener('click', () => {
      document.getElementById('info-overlay').style.display = 'block';
      document.getElementById('show-info').style.display = 'none';
    });

    // Update profile name display and show notification
    window.addEventListener('keypress', (event) => {
      if (event.key === 'p' || event.key === 'P') {
        setTimeout(() => {
          const profileNameEl = document.getElementById('profile-name');
          const notificationEl = document.getElementById('profile-notification');
          
          if (profileNameEl) {
            const currentText = profileNameEl.textContent;
            const newProfile = currentText === 'Default' ? 'Volkyri Aesthetic' : 'Default';
            profileNameEl.textContent = newProfile;
            
            // Show notification
            if (notificationEl) {
              notificationEl.textContent = `Profile: ${newProfile}`;
              notificationEl.style.display = 'block';
              setTimeout(() => {
                notificationEl.style.display = 'none';
              }, 2000);
            }
          }
        }, 100);
      } else if (event.key === 'c' || event.key === 'C') {
        // Handle color cycling notification
        setTimeout(() => {
          const notificationEl = document.getElementById('profile-notification');
          if (notificationEl) {
            // Will be updated by React component state change
            const colorNames = ['Teal', 'Magenta', 'Orange', 'Lime', 'Purple', 'Gold', 'Crimson', 'Cyan'];
            const currentColorIndex = parseInt(document.documentElement.style.getPropertyValue('--color-index') || '0');
            const nextIndex = (currentColorIndex + 1) % colorNames.length;
            
            notificationEl.textContent = `Color: ${colorNames[nextIndex]}`;
            notificationEl.style.display = 'block';
            setTimeout(() => {
              notificationEl.style.display = 'none';
            }, 2000);
          }
        }, 100);
      }
    });
  </script>
</body>
</html>
