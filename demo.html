<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ZeroPrompt WarpBG Demo - Interactive Warp Tunnel</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      overflow: hidden;
    }
    
    #root {
      width: 100vw;
      height: 100vh;
    }
    
    .controls-overlay {
      position: fixed;
      top: 20px;
      left: 20px;
      background: rgba(0, 0, 0, 0.8);
      color: #00CED1;
      padding: 20px;
      border-radius: 10px;
      font-size: 14px;
      max-width: 350px;
      border: 2px solid #00CED1;
      z-index: 1000;
      transition: opacity 0.3s ease;
    }
    
    .controls-overlay.hidden {
      opacity: 0;
      pointer-events: none;
    }
    
    .controls-overlay h2 {
      margin: 0 0 15px 0;
      font-size: 18px;
      color: #fff;
    }
    
    .control-item {
      margin: 8px 0;
      display: flex;
      align-items: center;
    }
    
    .key {
      display: inline-block;
      background: #00CED1;
      color: #000;
      padding: 4px 10px;
      border-radius: 4px;
      font-weight: bold;
      min-width: 30px;
      text-align: center;
      margin-right: 10px;
    }
    
    .description {
      color: #fff;
    }
    
    .toggle-button {
      position: fixed;
      top: 20px;
      right: 20px;
      background: rgba(0, 206, 209, 0.9);
      color: #000;
      border: none;
      padding: 10px 20px;
      border-radius: 5px;
      cursor: pointer;
      font-weight: bold;
      z-index: 1001;
      transition: background 0.3s ease;
    }
    
    .toggle-button:hover {
      background: rgba(0, 206, 209, 1);
    }
    
    .footer {
      position: fixed;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      color: rgba(255, 255, 255, 0.5);
      font-size: 12px;
      z-index: 1000;
    }
    
    .footer a {
      color: #00CED1;
      text-decoration: none;
    }
    
    .footer a:hover {
      text-decoration: underline;
    }
  </style>
</head>
<body>
  <div id="root"></div>
  
  <button class="toggle-button" onclick="toggleControls()">Toggle Controls</button>
  
  <div class="controls-overlay" id="controls">
    <h2>ðŸŽ® Keyboard Controls</h2>
    <div class="control-item">
      <span class="key">1</span>
      <span class="description">Decrease speed by 10%</span>
    </div>
    <div class="control-item">
      <span class="key">2</span>
      <span class="description">Reset to default speed</span>
    </div>
    <div class="control-item">
      <span class="key">3</span>
      <span class="description">Increase speed by 10%</span>
    </div>
    <div class="control-item">
      <span class="key">5</span>
      <span class="description">Toggle direction (forward â†” backward)</span>
    </div>
    <hr style="margin: 15px 0; border-color: #00CED1;">
    <p style="color: #fff; font-size: 12px; line-height: 1.6;">
      <strong>Features:</strong><br>
      â€¢ Smooth speed transitions with lerping<br>
      â€¢ Dynamic text size scaling with speed<br>
      â€¢ Particle count scales with speed<br>
      â€¢ Multi-line billboard text wrapping<br>
      â€¢ Procedurally generated prompts<br>
      â€¢ Fade-out effect in backward mode
    </p>
  </div>
  
  <div class="footer">
    ZeroPrompt WarpBG | 
    <a href="https://github.com/MushroomFleet/zeroprompt-warpBG-JSX" target="_blank">GitHub</a> | 
    Press any key to interact
  </div>

  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
  
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.157.0/build/three.module.js"
      }
    }
  </script>

  <!-- Inline the component for demo purposes -->
  <script type="text/babel" data-type="module">
    import * as THREE from 'three';
    const { useEffect, useRef } = React;

    // Paste the entire ZeroPromptWarpBG component code here
    // (All the vocabulary pools, hash functions, and component code)
    
    const SUBJECTS = [
      "a woman", "a man", "a young woman", "a young man", "an elderly woman",
      "an elderly man", "a child", "a teenager", "a couple", "a group of people",
      "a knight", "a wizard", "a witch", "a sorceress", "a necromancer",
      "a paladin", "a rogue", "an assassin", "a ranger", "a barbarian",
      "a druid", "a monk", "a bard", "a warlock", "an elven archer",
      "a dwarven smith", "an orc warrior", "a goblin", "a fairy", "a nymph",
      "a cyborg", "an android", "a robot", "a mech pilot", "an astronaut",
      "a space marine", "an alien", "a hacker", "a scientist", "a bounty hunter",
      "a samurai", "a ninja", "a viking", "a gladiator", "a pharaoh",
      "a geisha", "a shogun", "a roman soldier", "a medieval peasant", "a noble",
      "a detective", "a soldier", "a pilot", "a doctor", "an artist",
      "a musician", "a dancer", "an athlete", "a chef", "a photographer",
      "a dragon", "a phoenix", "a griffin", "a unicorn", "a werewolf",
      "a vampire", "a demon", "an angel", "a ghost", "a spirit",
      "a wolf", "a lion", "a tiger", "an eagle", "a raven",
      "a serpent", "a whale", "a shark", "a butterfly", "a spider",
      "a mechanical spider", "a clockwork automaton", "a golem", "a sentient statue",
      "a living shadow", "an elemental being", "a slime creature", "a treant"
    ];

    const ACTIONS = [
      "standing in", "sitting in", "kneeling in", "floating above", "hovering over",
      "resting in", "meditating in", "posing in", "waiting in", "watching over",
      "walking through", "running through", "flying over", "swimming in", "climbing",
      "falling into", "descending into", "ascending toward", "emerging from", "diving into",
      "fighting in", "battling through", "defending", "attacking", "dueling in",
      "charging through", "retreating from", "ambushing in", "hunting in",
      "exploring", "discovering", "searching through", "investigating",
      "uncovering secrets in", "finding treasure in", "mapping",
      "summoning power in", "casting a spell in", "channeling energy in",
      "communing with nature in", "praying in", "performing a ritual in",
      "transforming in", "shapeshifting in", "awakening in",
      "mourning in", "celebrating in", "contemplating in", "dreaming in",
      "remembering in", "lost in thought in"
    ];

    const ENVIRONMENTS = [
      "a dark forest", "an enchanted forest", "a misty forest", "a bamboo forest",
      "a snowy mountain", "a volcanic mountain", "a floating mountain",
      "a vast desert", "an oasis", "a canyon", "a waterfall", "a river",
      "a beach at sunset", "a stormy sea", "a coral reef", "an underwater cavern",
      "a medieval castle", "a ruined fortress", "a gothic cathedral",
      "an ancient temple", "a hidden shrine", "a sacred grove",
      "a wizard's tower", "an alchemist's laboratory", "a royal throne room",
      "a dungeon", "catacombs", "a crypt", "a graveyard at midnight",
      "a cyberpunk city", "a neon-lit alley", "a futuristic metropolis",
      "a space station", "an alien planet", "a terraformed moon",
      "a dystopian wasteland", "a post-apocalyptic city", "a megastructure",
      "a virtual reality world", "inside a computer mainframe",
      "a crystal cave", "a bioluminescent cavern", "a floating island",
      "the astral plane", "between dimensions", "the void",
      "a pocket dimension", "a mirror world", "a dream realm",
      "cherry blossom gardens", "an autumn forest", "a field of flowers",
      "under the northern lights", "during a solar eclipse",
      "at the edge of the world", "at the crossroads of fate"
    ];

    const STYLES = [
      "photorealistic", "hyperrealistic", "cinematic", "film still",
      "documentary photography", "portrait photography", "fashion photography",
      "oil painting", "watercolor painting", "acrylic painting", "gouache",
      "charcoal drawing", "pencil sketch", "ink drawing", "fresco",
      "art nouveau", "art deco", "baroque", "renaissance", "romanticism",
      "impressionist", "expressionist", "surrealist", "cubist",
      "pre-raphaelite", "ukiyo-e", "chinese ink wash",
      "concept art", "digital painting", "matte painting", "3D render",
      "low poly 3D", "voxel art", "pixel art", "vector art",
      "anime style", "manga style", "studio ghibli style", "disney style",
      "pixar style", "cartoon style", "comic book style", "graphic novel style",
      "vaporwave aesthetic", "synthwave", "cyberpunk aesthetic", "solarpunk",
      "dark academia", "cottagecore", "steampunk", "dieselpunk", "biopunk",
      "dark souls style", "elden ring style", "final fantasy style",
      "metal gear style", "borderlands style", "breath of the wild style"
    ];

    const MOOD = [
      "serene", "peaceful", "tranquil", "joyful", "euphoric",
      "whimsical", "playful", "romantic", "hopeful", "triumphant",
      "ominous", "foreboding", "melancholic", "sorrowful", "tragic",
      "terrifying", "horrific", "unsettling", "disturbing",
      "mysterious", "enigmatic", "surreal", "dreamlike", "ethereal",
      "nostalgic", "bittersweet", "contemplative", "introspective",
      "tense", "intense", "chaotic", "explosive", "dynamic",
      "calm", "still", "quiet", "subtle", "understated",
      "epic", "grand", "intimate", "cozy", "lonely", "isolated",
      "crowded", "bustling", "abandoned", "timeless"
    ];

    const POOLS = {
      subject: SUBJECTS,
      action: ACTIONS,
      environment: ENVIRONMENTS,
      style: STYLES,
      mood: MOOD
    };

    const TEMPLATES = [
      "{subject} {action} {environment}, {style}, {mood} atmosphere",
      "{subject} {action} {environment}, {mood} {style}",
      "{style} {subject}, {environment}, {mood} mood",
      "{subject} in {environment}, {mood} {style}",
      "{mood} scene of {subject} {action} {environment}, {style}",
      "{style} depicting {subject}, {environment} setting",
      "{subject}, {environment}, {style}, {mood} atmosphere",
      "{subject} {action} {environment}, {style}, {mood}"
    ];

    function simpleHash(seed, ...coords) {
      let hash = seed & 0xFFFFFFFF;
      for (let coord of coords) {
        hash ^= coord;
        hash = Math.imul(hash, 0x01000193);
      }
      return Math.abs(hash);
    }

    function hashToIndex(hash, poolSize) {
      return hash % poolSize;
    }

    function generatePrompt(seed, promptIdx) {
      const templateHash = simpleHash(seed, promptIdx, 0);
      const template = TEMPLATES[hashToIndex(templateHash, TEMPLATES.length)];
      
      const components = {};
      let i = 1;
      for (const [key, pool] of Object.entries(POOLS)) {
        const componentHash = simpleHash(seed, promptIdx, i);
        components[key] = pool[hashToIndex(componentHash, pool.length)];
        i++;
      }
      
      let result = template;
      for (const [key, value] of Object.entries(components)) {
        result = result.replace(`{${key}}`, value);
      }
      
      if (result.length > 100) {
        result = result.substring(0, 97) + "...";
      }
      
      return result;
    }

    const ZeroPromptWarpBG = () => {
      const containerRef = useRef(null);
      const sceneRef = useRef(null);
      const rendererRef = useRef(null);
      const cameraRef = useRef(null);
      const billboardsRef = useRef([]);
      const particlesRef = useRef(null);
      const seedRef = useRef(Math.floor(Math.random() * 0xFFFFFFFF));
      const promptIndexRef = useRef(0);
      
      const DEFAULT_SPEED = 1.0;
      const speedRef = useRef(DEFAULT_SPEED);
      const targetSpeedRef = useRef(DEFAULT_SPEED);
      const LERP_FACTOR = 0.05;
      
      const directionForwardRef = useRef(true);

      useEffect(() => {
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);
        sceneRef.current = scene;

        const camera = new THREE.PerspectiveCamera(
          75,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        camera.position.z = 0;
        cameraRef.current = camera;

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        containerRef.current.appendChild(renderer.domElement);
        rendererRef.current = renderer;

        const handleKeyPress = (event) => {
          if (event.key === '1') {
            targetSpeedRef.current = Math.max(0.1, targetSpeedRef.current * 0.9);
          } else if (event.key === '2') {
            targetSpeedRef.current = DEFAULT_SPEED;
          } else if (event.key === '3') {
            targetSpeedRef.current = Math.min(5.0, targetSpeedRef.current * 1.1);
          } else if (event.key === '5') {
            directionForwardRef.current = !directionForwardRef.current;
          }
        };
        
        window.addEventListener('keypress', handleKeyPress);

        const createBillboard = (index, currentSpeed, isForward) => {
          const text = generatePrompt(seedRef.current, promptIndexRef.current++);
          const fontSize = Math.floor(120 / Math.max(0.5, currentSpeed));
          
          const canvas = document.createElement('canvas');
          const context = canvas.getContext('2d');
          canvas.width = 2048;
          canvas.height = 768;
          
          context.fillStyle = '#000000';
          context.fillRect(0, 0, canvas.width, canvas.height);
          
          context.fillStyle = '#ffffff';
          context.font = `bold ${fontSize}px Arial`;
          context.textAlign = 'left';
          context.textBaseline = 'top';
          
          const maxWidth = canvas.width - 100;
          const lineHeight = fontSize * 1.2;
          const words = text.split(' ');
          const lines = [];
          let currentLine = '';
          
          for (let i = 0; i < words.length; i++) {
            const testLine = currentLine + (currentLine ? ' ' : '') + words[i];
            const metrics = context.measureText(testLine);
            
            if (metrics.width > maxWidth && currentLine) {
              lines.push(currentLine);
              currentLine = words[i];
            } else {
              currentLine = testLine;
            }
          }
          if (currentLine) {
            lines.push(currentLine);
          }
          
          const totalHeight = lines.length * lineHeight;
          const startY = (canvas.height - totalHeight) / 2;
          
          lines.forEach((line, index) => {
            const y = startY + (index * lineHeight);
            const x = (canvas.width - context.measureText(line).width) / 2;
            context.fillText(line, x, y);
          });
          
          const texture = new THREE.CanvasTexture(canvas);
          const opacity = Math.random() * 0.5 + 0.5;
          const material = new THREE.MeshBasicMaterial({
            map: texture,
            transparent: true,
            opacity: opacity,
            side: THREE.DoubleSide
          });
          
          const sizeMultiplier = 1 / Math.max(0.3, currentSpeed);
          const width = 20 * sizeMultiplier;
          const height = 7.5 * sizeMultiplier;
          
          const geometry = new THREE.PlaneGeometry(width, height);
          const billboard = new THREE.Mesh(geometry, material);
          
          const angle = Math.random() * Math.PI * 2;
          const radius = 15 + Math.random() * 10;
          
          let distance;
          if (isForward) {
            distance = -50 - Math.random() * 100;
          } else {
            distance = 5 + Math.random() * 15;
          }
          
          billboard.position.x = Math.cos(angle) * radius;
          billboard.position.y = Math.sin(angle) * radius - 5;
          billboard.position.z = distance;
          
          billboard.lookAt(camera.position);
          
          billboard.userData = {
            baseVelocity: 2 + Math.random() * 1,
            initialZ: distance,
            baseOpacity: opacity
          };
          
          scene.add(billboard);
          return billboard;
        };

        const numBillboards = 30;
        for (let i = 0; i < numBillboards; i++) {
          billboardsRef.current.push(createBillboard(i, DEFAULT_SPEED, true));
        }

        const particleCount = 1000;
        const particleGeometry = new THREE.BufferGeometry();
        const particlePositions = new Float32Array(particleCount * 3);
        const particleVelocities = new Float32Array(particleCount);
        const particleInitialZ = new Float32Array(particleCount);
        
        for (let i = 0; i < particleCount; i++) {
          const i3 = i * 3;
          const angle = Math.random() * Math.PI * 2;
          const radius = Math.random() * 30;
          
          particlePositions[i3] = Math.cos(angle) * radius;
          particlePositions[i3 + 1] = Math.sin(angle) * radius - 5;
          particlePositions[i3 + 2] = -Math.random() * 200;
          
          particleVelocities[i] = 2 + Math.random() * 1;
          particleInitialZ[i] = particlePositions[i3 + 2];
        }
        
        particleGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
        
        const particleMaterial = new THREE.PointsMaterial({
          color: 0x00CED1,
          size: 0.2,
          transparent: true,
          opacity: 0.6,
          blending: THREE.AdditiveBlending
        });
        
        const particles = new THREE.Points(particleGeometry, particleMaterial);
        particles.userData.velocities = particleVelocities;
        particles.userData.initialZ = particleInitialZ;
        particles.userData.activeCount = particleCount;
        scene.add(particles);
        particlesRef.current = particles;

        const animate = () => {
          requestAnimationFrame(animate);
          
          speedRef.current += (targetSpeedRef.current - speedRef.current) * LERP_FACTOR;
          
          const isForward = directionForwardRef.current;
          
          billboardsRef.current.forEach((billboard, index) => {
            billboard.lookAt(camera.position);
            
            if (isForward) {
              billboard.position.z += billboard.userData.baseVelocity * speedRef.current;
            } else {
              billboard.position.z -= billboard.userData.baseVelocity * speedRef.current;
            }
            
            if (!isForward) {
              const fadeStartDistance = -50;
              const fadeEndDistance = -150;
              
              if (billboard.position.z < fadeStartDistance) {
                const fadeProgress = Math.max(0, Math.min(1, 
                  (fadeStartDistance - billboard.position.z) / (fadeStartDistance - fadeEndDistance)
                ));
                billboard.material.opacity = billboard.userData.baseOpacity * (1 - fadeProgress);
              } else {
                billboard.material.opacity = billboard.userData.baseOpacity;
              }
            } else {
              billboard.material.opacity = billboard.userData.baseOpacity;
            }
            
            const shouldRecycle = isForward ? 
              (billboard.position.z > 10) : 
              (billboard.position.z < -150);
            
            if (shouldRecycle) {
              scene.remove(billboard);
              billboard.geometry.dispose();
              billboard.material.map.dispose();
              billboard.material.dispose();
              
              billboardsRef.current[index] = createBillboard(index, speedRef.current, isForward);
            }
          });
          
          const targetParticleCount = Math.floor(Math.min(1000, 100 + (speedRef.current * 900)));
          particles.userData.activeCount = targetParticleCount;
          
          const positions = particles.geometry.attributes.position.array;
          const velocities = particles.userData.velocities;
          const initialZ = particles.userData.initialZ;
          
          for (let i = 0; i < particleCount; i++) {
            const i3 = i * 3;
            
            if (i < particles.userData.activeCount) {
              if (isForward) {
                positions[i3 + 2] += velocities[i] * speedRef.current;
                
                if (positions[i3 + 2] > 10) {
                  positions[i3 + 2] = -200;
                  initialZ[i] = -200;
                }
              } else {
                positions[i3 + 2] -= velocities[i] * speedRef.current;
                
                if (positions[i3 + 2] < -200) {
                  positions[i3 + 2] = 10;
                  initialZ[i] = 10;
                }
              }
            } else {
              positions[i3 + 2] = -10000;
            }
          }
          
          particles.geometry.attributes.position.needsUpdate = true;
          
          renderer.render(scene, camera);
        };
        
        animate();

        const handleResize = () => {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(window.innerWidth, window.innerHeight);
        };
        
        window.addEventListener('resize', handleResize);

        return () => {
          window.removeEventListener('resize', handleResize);
          window.removeEventListener('keypress', handleKeyPress);
          
          billboardsRef.current.forEach(billboard => {
            scene.remove(billboard);
            billboard.geometry.dispose();
            billboard.material.map.dispose();
            billboard.material.dispose();
          });
          
          scene.remove(particles);
          particles.geometry.dispose();
          particles.material.dispose();
          
          renderer.dispose();
          if (containerRef.current && renderer.domElement) {
            containerRef.current.removeChild(renderer.domElement);
          }
        };
      }, []);

      return React.createElement('div', {
        ref: containerRef,
        style: {
          width: '100vw',
          height: '100vh',
          margin: 0,
          padding: 0,
          overflow: 'hidden',
          position: 'fixed',
          top: 0,
          left: 0
        }
      });
    };

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(React.createElement(ZeroPromptWarpBG));
  </script>

  <script>
    function toggleControls() {
      const controls = document.getElementById('controls');
      controls.classList.toggle('hidden');
    }
    
    // Auto-hide controls after 10 seconds
    setTimeout(() => {
      const controls = document.getElementById('controls');
      controls.classList.add('hidden');
    }, 10000);
  </script>
</body>
</html>
