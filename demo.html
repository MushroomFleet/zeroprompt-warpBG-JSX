<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ZeroPrompt WarpBG Demo - Interactive Warp Tunnel</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      overflow: hidden;
      background: #000;
    }
    
    #root {
      width: 100vw;
      height: 100vh;
    }
    
    .controls-overlay {
      position: fixed;
      top: 20px;
      left: 20px;
      background: rgba(0, 0, 0, 0.8);
      color: #00CED1;
      padding: 20px;
      border-radius: 10px;
      font-size: 14px;
      max-width: 350px;
      border: 2px solid #00CED1;
      z-index: 1000;
      transition: opacity 0.3s ease;
    }
    
    .controls-overlay.hidden {
      opacity: 0;
      pointer-events: none;
    }
    
    .controls-overlay h2 {
      margin: 0 0 15px 0;
      font-size: 18px;
      color: #fff;
    }
    
    .control-item {
      margin: 8px 0;
      display: flex;
      align-items: center;
    }
    
    .key {
      display: inline-block;
      background: #00CED1;
      color: #000;
      padding: 4px 10px;
      border-radius: 4px;
      font-weight: bold;
      min-width: 30px;
      text-align: center;
      margin-right: 10px;
    }
    
    .description {
      color: #fff;
    }
    
    .toggle-button {
      position: fixed;
      top: 20px;
      right: 20px;
      background: rgba(0, 206, 209, 0.9);
      color: #000;
      border: none;
      padding: 10px 20px;
      border-radius: 5px;
      cursor: pointer;
      font-weight: bold;
      z-index: 1001;
      transition: background 0.3s ease;
    }
    
    .toggle-button:hover {
      background: rgba(0, 206, 209, 1);
    }
    
    .footer {
      position: fixed;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      color: rgba(255, 255, 255, 0.5);
      font-size: 12px;
      z-index: 1000;
    }
    
    .footer a {
      color: #00CED1;
      text-decoration: none;
    }
    
    .footer a:hover {
      text-decoration: underline;
    }
  </style>
</head>
<body>
  <div id="root"></div>
  
  <button class="toggle-button" onclick="toggleControls()">Toggle Controls</button>
  
  <div class="controls-overlay" id="controls">
    <h2>ðŸŽ® Keyboard Controls</h2>
    <div class="control-item">
      <span class="key">1</span>
      <span class="description">Decrease speed by 10%</span>
    </div>
    <div class="control-item">
      <span class="key">2</span>
      <span class="description">Reset to default speed</span>
    </div>
    <div class="control-item">
      <span class="key">3</span>
      <span class="description">Increase speed by 10%</span>
    </div>
    <div class="control-item">
      <span class="key">5</span>
      <span class="description">Toggle direction (forward â†” backward)</span>
    </div>
    <hr style="margin: 15px 0; border-color: #00CED1;">
    <p style="color: #fff; font-size: 12px; line-height: 1.6;">
      <strong>Features:</strong><br>
      â€¢ Smooth speed transitions with lerping<br>
      â€¢ Dynamic text size scaling with speed<br>
      â€¢ Particle count scales with speed<br>
      â€¢ Multi-line billboard text wrapping<br>
      â€¢ Procedurally generated prompts<br>
      â€¢ Fade-out effect in backward mode
    </p>
  </div>
  
  <div class="footer">
    ZeroPrompt WarpBG | 
    <a href="https://github.com/MushroomFleet/zeroprompt-warpBG-JSX" target="_blank">GitHub</a> | 
    Press any key to interact
  </div>

  <!-- React and ReactDOM from CDN -->
  <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
  <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
  
  <!-- Three.js from CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

  <script>
    (function() {
      'use strict';
      
      // Vocabulary pools
      const SUBJECTS = [
        "a woman", "a man", "a young woman", "a young man", "an elderly woman",
        "an elderly man", "a child", "a teenager", "a couple", "a group of people",
        "a knight", "a wizard", "a witch", "a sorceress", "a necromancer",
        "a paladin", "a rogue", "an assassin", "a ranger", "a barbarian",
        "a druid", "a monk", "a bard", "a warlock", "an elven archer",
        "a dwarven smith", "an orc warrior", "a goblin", "a fairy", "a nymph",
        "a cyborg", "an android", "a robot", "a mech pilot", "an astronaut",
        "a space marine", "an alien", "a hacker", "a scientist", "a bounty hunter",
        "a samurai", "a ninja", "a viking", "a gladiator", "a pharaoh",
        "a geisha", "a shogun", "a roman soldier", "a medieval peasant", "a noble",
        "a detective", "a soldier", "a pilot", "a doctor", "an artist",
        "a musician", "a dancer", "an athlete", "a chef", "a photographer",
        "a dragon", "a phoenix", "a griffin", "a unicorn", "a werewolf",
        "a vampire", "a demon", "an angel", "a ghost", "a spirit",
        "a wolf", "a lion", "a tiger", "an eagle", "a raven",
        "a serpent", "a whale", "a shark", "a butterfly", "a spider",
        "a mechanical spider", "a clockwork automaton", "a golem", "a sentient statue",
        "a living shadow", "an elemental being", "a slime creature", "a treant"
      ];

      const ACTIONS = [
        "standing in", "sitting in", "kneeling in", "floating above", "hovering over",
        "resting in", "meditating in", "posing in", "waiting in", "watching over",
        "walking through", "running through", "flying over", "swimming in", "climbing",
        "falling into", "descending into", "ascending toward", "emerging from", "diving into",
        "fighting in", "battling through", "defending", "attacking", "dueling in",
        "charging through", "retreating from", "ambushing in", "hunting in",
        "exploring", "discovering", "searching through", "investigating",
        "uncovering secrets in", "finding treasure in", "mapping",
        "summoning power in", "casting a spell in", "channeling energy in",
        "communing with nature in", "praying in", "performing a ritual in",
        "transforming in", "shapeshifting in", "awakening in",
        "mourning in", "celebrating in", "contemplating in", "dreaming in",
        "remembering in", "lost in thought in"
      ];

      const ENVIRONMENTS = [
        "a dark forest", "an enchanted forest", "a misty forest", "a bamboo forest",
        "a snowy mountain", "a volcanic mountain", "a floating mountain",
        "a vast desert", "an oasis", "a canyon", "a waterfall", "a river",
        "a beach at sunset", "a stormy sea", "a coral reef", "an underwater cavern",
        "a medieval castle", "a ruined fortress", "a gothic cathedral",
        "an ancient temple", "a hidden shrine", "a sacred grove",
        "a wizard's tower", "an alchemist's laboratory", "a royal throne room",
        "a dungeon", "catacombs", "a crypt", "a graveyard at midnight",
        "a cyberpunk city", "a neon-lit alley", "a futuristic metropolis",
        "a space station", "an alien planet", "a terraformed moon",
        "a dystopian wasteland", "a post-apocalyptic city", "a megastructure",
        "a virtual reality world", "inside a computer mainframe",
        "a crystal cave", "a bioluminescent cavern", "a floating island",
        "the astral plane", "between dimensions", "the void",
        "a pocket dimension", "a mirror world", "a dream realm",
        "cherry blossom gardens", "an autumn forest", "a field of flowers",
        "under the northern lights", "during a solar eclipse",
        "at the edge of the world", "at the crossroads of fate"
      ];

      const STYLES = [
        "photorealistic", "hyperrealistic", "cinematic", "film still",
        "documentary photography", "portrait photography", "fashion photography",
        "oil painting", "watercolor painting", "acrylic painting", "gouache",
        "charcoal drawing", "pencil sketch", "ink drawing", "fresco",
        "art nouveau", "art deco", "baroque", "renaissance", "romanticism",
        "impressionist", "expressionist", "surrealist", "cubist",
        "pre-raphaelite", "ukiyo-e", "chinese ink wash",
        "concept art", "digital painting", "matte painting", "3D render",
        "low poly 3D", "voxel art", "pixel art", "vector art",
        "anime style", "manga style", "studio ghibli style", "disney style",
        "pixar style", "cartoon style", "comic book style", "graphic novel style",
        "vaporwave aesthetic", "synthwave", "cyberpunk aesthetic", "solarpunk",
        "dark academia", "cottagecore", "steampunk", "dieselpunk", "biopunk",
        "dark souls style", "elden ring style", "final fantasy style",
        "metal gear style", "borderlands style", "breath of the wild style"
      ];

      const MOOD = [
        "serene", "peaceful", "tranquil", "joyful", "euphoric",
        "whimsical", "playful", "romantic", "hopeful", "triumphant",
        "ominous", "foreboding", "melancholic", "sorrowful", "tragic",
        "terrifying", "horrific", "unsettling", "disturbing",
        "mysterious", "enigmatic", "surreal", "dreamlike", "ethereal",
        "nostalgic", "bittersweet", "contemplative", "introspective",
        "tense", "intense", "chaotic", "explosive", "dynamic",
        "calm", "still", "quiet", "subtle", "understated",
        "epic", "grand", "intimate", "cozy", "lonely", "isolated",
        "crowded", "bustling", "abandoned", "timeless"
      ];

      const POOLS = {
        subject: SUBJECTS,
        action: ACTIONS,
        environment: ENVIRONMENTS,
        style: STYLES,
        mood: MOOD
      };

      const TEMPLATES = [
        "{subject} {action} {environment}, {style}, {mood} atmosphere",
        "{subject} {action} {environment}, {mood} {style}",
        "{style} {subject}, {environment}, {mood} mood",
        "{subject} in {environment}, {mood} {style}",
        "{mood} scene of {subject} {action} {environment}, {style}",
        "{style} depicting {subject}, {environment} setting",
        "{subject}, {environment}, {style}, {mood} atmosphere",
        "{subject} {action} {environment}, {style}, {mood}"
      ];

      function simpleHash(seed) {
        var coords = Array.prototype.slice.call(arguments, 1);
        var hash = seed & 0xFFFFFFFF;
        for (var i = 0; i < coords.length; i++) {
          hash ^= coords[i];
          hash = Math.imul(hash, 0x01000193);
        }
        return Math.abs(hash);
      }

      function hashToIndex(hash, poolSize) {
        return hash % poolSize;
      }

      function generatePrompt(seed, promptIdx) {
        var templateHash = simpleHash(seed, promptIdx, 0);
        var template = TEMPLATES[hashToIndex(templateHash, TEMPLATES.length)];
        
        var components = {};
        var i = 1;
        var poolKeys = Object.keys(POOLS);
        for (var j = 0; j < poolKeys.length; j++) {
          var key = poolKeys[j];
          var pool = POOLS[key];
          var componentHash = simpleHash(seed, promptIdx, i);
          components[key] = pool[hashToIndex(componentHash, pool.length)];
          i++;
        }
        
        var result = template;
        for (var k = 0; k < poolKeys.length; k++) {
          var key = poolKeys[k];
          result = result.replace('{' + key + '}', components[key]);
        }
        
        if (result.length > 100) {
          result = result.substring(0, 97) + "...";
        }
        
        return result;
      }

      // Component
      function ZeroPromptWarpBG() {
        var containerRef = React.useRef(null);
        var sceneRef = React.useRef(null);
        var rendererRef = React.useRef(null);
        var cameraRef = React.useRef(null);
        var billboardsRef = React.useRef([]);
        var particlesRef = React.useRef(null);
        var seedRef = React.useRef(Math.floor(Math.random() * 0xFFFFFFFF));
        var promptIndexRef = React.useRef(0);
        
        var DEFAULT_SPEED = 1.0;
        var speedRef = React.useRef(DEFAULT_SPEED);
        var targetSpeedRef = React.useRef(DEFAULT_SPEED);
        var LERP_FACTOR = 0.05;
        var directionForwardRef = React.useRef(true);

        React.useEffect(function() {
          var scene = new THREE.Scene();
          scene.background = new THREE.Color(0x000000);
          sceneRef.current = scene;

          var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
          camera.position.z = 0;
          cameraRef.current = camera;

          var renderer = new THREE.WebGLRenderer({ antialias: true });
          renderer.setSize(window.innerWidth, window.innerHeight);
          containerRef.current.appendChild(renderer.domElement);
          rendererRef.current = renderer;

          var handleKeyPress = function(event) {
            if (event.key === '1') {
              targetSpeedRef.current = Math.max(0.1, targetSpeedRef.current * 0.9);
            } else if (event.key === '2') {
              targetSpeedRef.current = DEFAULT_SPEED;
            } else if (event.key === '3') {
              targetSpeedRef.current = Math.min(5.0, targetSpeedRef.current * 1.1);
            } else if (event.key === '5') {
              directionForwardRef.current = !directionForwardRef.current;
            }
          };
          
          window.addEventListener('keypress', handleKeyPress);

          var createBillboard = function(index, currentSpeed, isForward) {
            var text = generatePrompt(seedRef.current, promptIndexRef.current++);
            var fontSize = Math.floor(120 / Math.max(0.5, currentSpeed));
            
            var canvas = document.createElement('canvas');
            var context = canvas.getContext('2d');
            canvas.width = 2048;
            canvas.height = 768;
            
            context.fillStyle = '#000000';
            context.fillRect(0, 0, canvas.width, canvas.height);
            
            context.fillStyle = '#ffffff';
            context.font = 'bold ' + fontSize + 'px Arial';
            context.textAlign = 'left';
            context.textBaseline = 'top';
            
            var maxWidth = canvas.width - 100;
            var lineHeight = fontSize * 1.2;
            var words = text.split(' ');
            var lines = [];
            var currentLine = '';
            
            for (var i = 0; i < words.length; i++) {
              var testLine = currentLine + (currentLine ? ' ' : '') + words[i];
              var metrics = context.measureText(testLine);
              
              if (metrics.width > maxWidth && currentLine) {
                lines.push(currentLine);
                currentLine = words[i];
              } else {
                currentLine = testLine;
              }
            }
            if (currentLine) {
              lines.push(currentLine);
            }
            
            var totalHeight = lines.length * lineHeight;
            var startY = (canvas.height - totalHeight) / 2;
            
            for (var i = 0; i < lines.length; i++) {
              var line = lines[i];
              var y = startY + (i * lineHeight);
              var x = (canvas.width - context.measureText(line).width) / 2;
              context.fillText(line, x, y);
            }
            
            var texture = new THREE.CanvasTexture(canvas);
            var opacity = Math.random() * 0.5 + 0.5;
            var material = new THREE.MeshBasicMaterial({
              map: texture,
              transparent: true,
              opacity: opacity,
              side: THREE.DoubleSide
            });
            
            var sizeMultiplier = 1 / Math.max(0.3, currentSpeed);
            var width = 20 * sizeMultiplier;
            var height = 7.5 * sizeMultiplier;
            
            var geometry = new THREE.PlaneGeometry(width, height);
            var billboard = new THREE.Mesh(geometry, material);
            
            var angle = Math.random() * Math.PI * 2;
            var radius = 15 + Math.random() * 10;
            
            var distance;
            if (isForward) {
              distance = -50 - Math.random() * 100;
            } else {
              distance = 5 + Math.random() * 15;
            }
            
            billboard.position.x = Math.cos(angle) * radius;
            billboard.position.y = Math.sin(angle) * radius - 5;
            billboard.position.z = distance;
            
            billboard.lookAt(camera.position);
            
            billboard.userData = {
              baseVelocity: 2 + Math.random() * 1,
              initialZ: distance,
              baseOpacity: opacity
            };
            
            scene.add(billboard);
            return billboard;
          };

          var numBillboards = 30;
          for (var i = 0; i < numBillboards; i++) {
            billboardsRef.current.push(createBillboard(i, DEFAULT_SPEED, true));
          }

          var particleCount = 1000;
          var particleGeometry = new THREE.BufferGeometry();
          var particlePositions = new Float32Array(particleCount * 3);
          var particleVelocities = new Float32Array(particleCount);
          var particleInitialZ = new Float32Array(particleCount);
          
          for (var i = 0; i < particleCount; i++) {
            var i3 = i * 3;
            var angle = Math.random() * Math.PI * 2;
            var radius = Math.random() * 30;
            
            particlePositions[i3] = Math.cos(angle) * radius;
            particlePositions[i3 + 1] = Math.sin(angle) * radius - 5;
            particlePositions[i3 + 2] = -Math.random() * 200;
            
            particleVelocities[i] = 2 + Math.random() * 1;
            particleInitialZ[i] = particlePositions[i3 + 2];
          }
          
          particleGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
          
          var particleMaterial = new THREE.PointsMaterial({
            color: 0x00CED1,
            size: 0.2,
            transparent: true,
            opacity: 0.6,
            blending: THREE.AdditiveBlending
          });
          
          var particles = new THREE.Points(particleGeometry, particleMaterial);
          particles.userData.velocities = particleVelocities;
          particles.userData.initialZ = particleInitialZ;
          particles.userData.activeCount = particleCount;
          scene.add(particles);
          particlesRef.current = particles;

          var animate = function() {
            requestAnimationFrame(animate);
            
            speedRef.current += (targetSpeedRef.current - speedRef.current) * LERP_FACTOR;
            
            var isForward = directionForwardRef.current;
            
            for (var i = 0; i < billboardsRef.current.length; i++) {
              var billboard = billboardsRef.current[i];
              billboard.lookAt(camera.position);
              
              if (isForward) {
                billboard.position.z += billboard.userData.baseVelocity * speedRef.current;
              } else {
                billboard.position.z -= billboard.userData.baseVelocity * speedRef.current;
              }
              
              if (!isForward) {
                var fadeStartDistance = -50;
                var fadeEndDistance = -150;
                
                if (billboard.position.z < fadeStartDistance) {
                  var fadeProgress = Math.max(0, Math.min(1, 
                    (fadeStartDistance - billboard.position.z) / (fadeStartDistance - fadeEndDistance)
                  ));
                  billboard.material.opacity = billboard.userData.baseOpacity * (1 - fadeProgress);
                } else {
                  billboard.material.opacity = billboard.userData.baseOpacity;
                }
              } else {
                billboard.material.opacity = billboard.userData.baseOpacity;
              }
              
              var shouldRecycle = isForward ? 
                (billboard.position.z > 10) : 
                (billboard.position.z < -150);
              
              if (shouldRecycle) {
                scene.remove(billboard);
                billboard.geometry.dispose();
                billboard.material.map.dispose();
                billboard.material.dispose();
                
                billboardsRef.current[i] = createBillboard(i, speedRef.current, isForward);
              }
            }
            
            var targetParticleCount = Math.floor(Math.min(1000, 100 + (speedRef.current * 900)));
            particles.userData.activeCount = targetParticleCount;
            
            var positions = particles.geometry.attributes.position.array;
            var velocities = particles.userData.velocities;
            var initialZ = particles.userData.initialZ;
            
            for (var i = 0; i < particleCount; i++) {
              var i3 = i * 3;
              
              if (i < particles.userData.activeCount) {
                if (isForward) {
                  positions[i3 + 2] += velocities[i] * speedRef.current;
                  
                  if (positions[i3 + 2] > 10) {
                    positions[i3 + 2] = -200;
                    initialZ[i] = -200;
                  }
                } else {
                  positions[i3 + 2] -= velocities[i] * speedRef.current;
                  
                  if (positions[i3 + 2] < -200) {
                    positions[i3 + 2] = 10;
                    initialZ[i] = 10;
                  }
                }
              } else {
                positions[i3 + 2] = -10000;
              }
            }
            
            particles.geometry.attributes.position.needsUpdate = true;
            
            renderer.render(scene, camera);
          };
          
          animate();

          var handleResize = function() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
          };
          
          window.addEventListener('resize', handleResize);

          return function() {
            window.removeEventListener('resize', handleResize);
            window.removeEventListener('keypress', handleKeyPress);
            
            for (var i = 0; i < billboardsRef.current.length; i++) {
              var billboard = billboardsRef.current[i];
              scene.remove(billboard);
              billboard.geometry.dispose();
              billboard.material.map.dispose();
              billboard.material.dispose();
            }
            
            scene.remove(particles);
            particles.geometry.dispose();
            particles.material.dispose();
            
            renderer.dispose();
            if (containerRef.current && renderer.domElement) {
              containerRef.current.removeChild(renderer.domElement);
            }
          };
        }, []);

        return React.createElement('div', {
          ref: containerRef,
          style: {
            width: '100vw',
            height: '100vh',
            margin: 0,
            padding: 0,
            overflow: 'hidden',
            position: 'fixed',
            top: 0,
            left: 0
          }
        });
      }

      var root = ReactDOM.createRoot(document.getElementById('root'));
      root.render(React.createElement(ZeroPromptWarpBG));
    })();
  </script>

  <script>
    function toggleControls() {
      var controls = document.getElementById('controls');
      controls.classList.toggle('hidden');
    }
    
    // Auto-hide controls after 10 seconds
    setTimeout(function() {
      var controls = document.getElementById('controls');
      controls.classList.add('hidden');
    }, 10000);
  </script>
</body>
</html>
